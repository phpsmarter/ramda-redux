# A library of convenient function by Jituan Lin
 
This is Jituan Lin 's utils library, maybe is also helpful for you.

## This project is power by [**Ramda.js**](http://ramdajs.com/)

## Note:.
- *Almost function is curring for you.*

- *berserk depend on **ramda**,ensure you install ramda correctly.*

## How to use

1. install **berserk** <br>
    `npm install berserk`

2. import or require the *berserk*, depend your environment.

	1. in node.js
	
	```js
		const j =require('berserk')
	    // berserk include a whole Ramda.js in it
		j.log('great: ',j.always('hello world'))
	    // will log:
	    //  GREAT:
	    //      hello world
	```
	2. with webpack 
	
	```js
	    import j from 'berserk'
        //berserk also has it's own function
	    j.midFlow(
    	    [
   	    	    ({a})=>({b:a+1}),
   	    	    ({b})=>({c:a+b}),
  	    	    (obj)=>j.log(obj)
   	        ]
         )({a:1})
        //log: { a:1, b:2 , c:3 }
	```
	
	```js
      const {readdir} =require('fs')
      const readdirP=toPromise(readdir)
      readdir(Path)
        .then(
          files=>console.log(files),
          (err)=>console.log(err)
          )
  
    ```
	
## How to build

`npm run build`

## How to test

`npm run test`

## Generate API doc

`npm run doc`

## API doc
### Functions

<dl>
<dt><a href="#checkErr">checkErr(res, rej)</a> ⇒ <code>function</code></dt>
<dd><p>A convenient function for handle error in callback function.
Accept two function res(resolve) and rej(reject) ,
return a wrap function that accept a list arguments,
the first argument as error, if error is null,
the res function will call,else the rej function.</p>
</dd>
<dt><a href="#debug">debug(title)</a> ⇒ <code>function</code></dt>
<dd><p>accept a title, return a function,
the return function accept any data then log it with title(for better debug),
then return the data back</p>
</dd>
<dt><a href="#flow">flow(data, ...funList)</a></dt>
<dd><p>Same as ramda&#39;s pipe, but will accept a data and some function as
it&#39;s arguments.Then call first function with data and past the result as
arguments of next function, then call the second function as previous function result
chain by chain...</p>
</dd>
<dt><a href="#isSuperSet">isSuperSet(childSet, supperSet)</a></dt>
<dd><p>Judge a set is it another set&#39;s childSet</p>
</dd>
<dt><a href="#log">log(title, content)</a></dt>
<dd><p>Better log function, will accept title and content as it&#39;s arguments,
then console.log it</p>
</dd>
<dt><a href="#Matcher">Matcher(...matcherList)</a></dt>
<dd><p>Same as ramda&#39;s cond,but more readable</p>
</dd>
<dt><a href="#midFlow">midFlow(mids)</a> ⇒ <code>function</code></dt>
<dd><p>the middleware must accept a object as &#39;context&#39; and return a object to merge to context</p>
</dd>
<dt><a href="#Pair">Pair(first, second)</a></dt>
<dd><p>The factory function to construct a single pair</p>
</dd>
<dt><a href="#sameTo">sameTo()</a> ⇒ <code>any</code></dt>
<dd><p>A function return a unit what pass to it</p>
</dd>
<dt><a href="#setEq">setEq(set1, set2)</a> ⇒ <code>boolean</code></dt>
<dd><p>Compare whether two set (es6: new Set(iterable)) is same as.</p>
</dd>
<dt><a href="#toPromise">toPromise(fun)</a> ⇒ <code>function</code></dt>
<dd><p>Wrap the callback style function to Promise style function,
the callback style function must restrict by convention:</p>
<ol>
<li>the function must put the callback function where the last of arguments,
such as (arg1,arg2,arg3,arg...,callback)</li>
<li>the callback function must call as callback(err,arg1，arg2,arg...)</li>
</ol>
</dd>
</dl>

<a name="checkErr"></a>

### checkErr(res, rej) ⇒ <code>function</code>
A convenient function for handle error in callback function.
Accept two function res(resolve) and rej(reject) ,
return a wrap function that accept a list arguments,
the first argument as error, if error is null,
the res function will call,else the rej function.

**Kind**: global function  
**Returns**: <code>function</code> - return a function that accept a list arguments,
the first argument as error, if error is null, the res function
will call,else the rej function  

| Param | Type | Description |
| --- | --- | --- |
| res | <code>function</code> | the function which will call when no error throw |
| rej | <code>function</code> | the function which will call when  error occur |

<a name="debug"></a>

### debug(title) ⇒ <code>function</code>
accept a title, return a function,
the return function accept any data then log it with title(for better debug),
then return the data back

**Kind**: global function  

| Param | Type |
| --- | --- |
| title | <code>any</code> | 

**Example**  
```js
debug('the great')('hello world')
// will log 'THE GREAT: hello world',and return
// => 'hello world'
```
<a name="flow"></a>

### flow(data, ...funList)
Same as ramda's pipe, but will accept a data and some function as
it's arguments.Then call first function with data and past the result as
arguments of next function, then call the second function as previous function result
chain by chain...

**Kind**: global function  

| Param | Type |
| --- | --- |
| data | <code>any</code> | 
| ...funList | <code>function</code> | 

**Example**  
```js
flow(
	1,
	R.inc,
	R.inc
)
//=> 3
```
<a name="isSuperSet"></a>

### isSuperSet(childSet, supperSet)
Judge a set is it another set's childSet

**Kind**: global function  

| Param | Type |
| --- | --- |
| childSet | <code>Set</code> | 
| supperSet | <code>Set</code> | 

**Example**  
```js
isSupperSet(
		new Set([1, {a: 2}, 3]),
		new Set([1, {a: 2}, 3, 4])
)
// return false
```
<a name="log"></a>

### log(title, content)
Better log function, will accept title and content as it's arguments,
then console.log it

**Kind**: global function  

| Param | Type |
| --- | --- |
| title | <code>any</code> | 
| content | <code>any</code> | 

**Example**  
```js
const j =require('berserk')
const fs =require('fs')
fs.readdir(
	'path',
	j.ifErr(j.log('success'),j.log(error occur))
)
// will print 'SUCCESS: ['file1','file2'...]',if not error thrown
// otherwise print 'ERROR OCCUR: error message'
```
<a name="Matcher"></a>

### Matcher(...matcherList)
Same as ramda's cond,but more readable

**Kind**: global function  

| Param | Type |
| --- | --- |
| ...matcherList | <code>array</code> | 

**Example**  
```js
const j=require('berserk')
const Pattern=Pair
const matcher=Matcher(
		Pattern(R.is(Array),R.head),
		Pattern(R.T,R.always('no match'))
)
mather([1,2,3])
//=> 1
```
<a name="midFlow"></a>

### midFlow(mids) ⇒ <code>function</code>
the middleware must accept a object as 'context' and return a object to merge to context

**Kind**: global function  
**Returns**: <code>function</code> - A function that accept a object as initial 'context' pass to first middleware  

| Param | Type | Description |
| --- | --- | --- |
| mids | <code>array</code> | a array of middleware, |

**Example**  
```js
// A function use midFlow for create a element(browser) by option
const elm = j.midFlow(
    [
       ({tag}) => ({el: document.createElement(tag)}),
       ({el, attr = {}}) => {
            R.forEachObjIndexed(
                 (value, name) => el[name] = value,
                 attr
             )
          },
        ({children = [], el}) => {
            j.midFlow(
                 [
                     ({doc}) => {
                         R.forEach(
                             (child) => doc.appendChild(child),
                             children
                         )
                       },
                      ({doc}) => {el.appendChild(doc)}
                  ]
            )({doc: new DocumentFragment})
         },
        ({evtLir = [], el}) => {
              R.forEach(
                 ({handler, type, opt = {}}) => el.addEventListener(type, handler, opt),
                  evtLir
               )
         },
       ({el}) => el
   ]
)
```
<a name="Pair"></a>

### Pair(first, second)
The factory function to construct a single pair

**Kind**: global function  

| Param | Type |
| --- | --- |
| first | <code>any</code> | 
| second | <code>any</code> | 

**Example**  
```js
const pair=Pair('name','jituanlin')
//=> ['name','jituanlin']
```
<a name="sameTo"></a>

### sameTo() ⇒ <code>any</code>
A function return a unit what pass to it

**Kind**: global function  
**Params**: <code>any</code>  
**Example**  
```js
sameTo('hello world!')
// return 'hello world!'
```
<a name="setEq"></a>

### setEq(set1, set2) ⇒ <code>boolean</code>
Compare whether two set (es6: new Set(iterable)) is same as.

**Kind**: global function  

| Param | Type |
| --- | --- |
| set1 | <code>Set</code> | 
| set2 | <code>Set</code> | 

**Example**  
```js
j.setEq(
   new Set([1, 2, 3]),
   new Set([3, 2, 1])
) // return true

j.setEq(
   new Set([1, 2]),
     new Set([1, 2, 3])
)// return false
```
<a name="toPromise"></a>

### toPromise(fun) ⇒ <code>function</code>
Wrap the callback style function to Promise style function,
the callback style function must restrict by convention:
1. the function must put the callback function where the last of arguments,
such as (arg1,arg2,arg3,arg...,callback)
2. the callback function must call as callback(err,arg1，arg2,arg...)

**Kind**: global function  
**Returns**: <code>function</code> - Return the new function that will return a Promise,
while the origin function throw a error, the Promise will be Promise.reject(error),
while the origin function work fine, the Promise will be Promise.resolve(args: array),
the args is which callback function accept  

| Param | Type | Description |
| --- | --- | --- |
| fun | <code>function</code> | The callback style function to transform |

**Example**  
```js
const {readdir} =require('fs')
   const readdirP=toPromise(readdir)
   readdir(Path)
     .then(
       files=>console.log(files),
       (err)=>console.log(err)
       )
```
